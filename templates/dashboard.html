{% extends "base.html" %}

{% block title %}GPS Data Dashboard{% endblock %}

{% block content %}
<div class="map-container">
    <div id="map" style="width: 100%; height: 300px;"></div>
    <button id="mark-point">Mark Point</button>
    <button id="save-polygon">Save Polygon</button>
    <button id="show-polygon">Show Polygon</button>
    <label for="start-point">Select Start Point:</label>
    <select id="start-point">
        <option value="">Select a point</option>
    </select>
    <label for="angle-point">Select Angle Point:</label>
    <select id="angle-point">
        <option value="">Select a point</option>
    </select>
    <button id="plan-path">Plan Path</button>
    <div class="data-table">
        <h2>GPS Data</h2>
        <table id="gps-data-table">
            <tr>
                <th>Timestamp</th>
                <th>Latitude</th>
                <th>Longitude</th>
            </tr>
        </table>
    </div>
</div>
<div class="chart-container">
    <canvas id="cpuChart" width="400" height="200"></canvas>
    <div class="data-table">
        <h2>CPU Usage (Last Minute)</h2>
        <table id="cpu-data-table">
            <tr>
                <th>Timestamp</th>
                <th>Core</th>
                <th>CPU Usage (%)</th>
            </tr>
        </table>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    var map = L.map('map').setView([{{ current_coordinates['lat'] }}, {{ current_coordinates['lon'] }}], 13);  // Initialize map with current coordinates and zoom level 13
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 22  // Allow for a higher maximum zoom level
    }).addTo(map);

    var polyline = L.polyline([], {color: 'blue'}).addTo(map);
    var currentPolygon = [];
    var polygon;
    var pathLine;
    var startPointMarker;
    var anglePointMarker;

    document.getElementById('mark-point').addEventListener('click', function() {
        fetch('/data')
            .then(response => response.json())
            .then(data => {
                var currentLatLng = L.latLng(data.current_coordinates.lat, data.current_coordinates.lon);
                currentPolygon.push(currentLatLng);
                if (currentPolygon.length > 1) {
                    if (polygon) {
                        map.removeLayer(polygon);
                    }
                    polygon = L.polygon(currentPolygon, {color: 'red'}).addTo(map);
                    console.log("Current polygon coordinates:", currentPolygon);
                }
                updateDropdowns();
            })
            .catch(error => console.error('Error fetching current coordinates:', error));
    });

    document.getElementById('save-polygon').addEventListener('click', function() {
        var polygonCoordinates = currentPolygon.map(function(latlng) {
            return {lat: latlng.lat, lon: latlng.lng};
        });
        fetch('/save_polygon', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({polygon: polygonCoordinates})
        })
        .then(response => response.json())
        .then(data => {
            console.log('Polygon saved:', data);
        })
        .catch((error) => {
            console.error('Error:', error);
        });
    });

    document.getElementById('show-polygon').addEventListener('click', function() {
        fetch('/polygon_data')
            .then(response => response.json())
            .then(data => {
                console.log('Fetched polygon data:', data);
                if (polygon) {
                    map.removeLayer(polygon);
                }
                var polygonCoordinates = data.map(function(coord) {
                    return [coord.lat, coord.lon];
                });
                console.log('Polygon coordinates for Leaflet:', polygonCoordinates);
                polygon = L.polygon(polygonCoordinates, {color: 'green'}).addTo(map);
                currentPolygon = polygonCoordinates.map(function(coord) {
                    return L.latLng(coord[0], coord[1]);
                });
                updateDropdowns();
            })
            .catch((error) => {
                console.error('Error:', error);
            });
    });

    document.getElementById('start-point').addEventListener('change', function() {
        var startPointSelect = document.getElementById('start-point');
        var selectedStartPointOption = startPointSelect.options[startPointSelect.selectedIndex];
        var startPoint = selectedStartPointOption.value ? JSON.parse(selectedStartPointOption.value) : null;

        if (startPointMarker) {
            map.removeLayer(startPointMarker);
        }
        if (startPoint) {
            startPointMarker = L.marker([startPoint.lat, startPoint.lon], {color: 'blue'}).addTo(map);
        }
    });

    document.getElementById('angle-point').addEventListener('change', function() {
        var anglePointSelect = document.getElementById('angle-point');
        var selectedAnglePointOption = anglePointSelect.options[anglePointSelect.selectedIndex];
        var anglePoint = selectedAnglePointOption.value ? JSON.parse(selectedAnglePointOption.value) : null;

        if (anglePointMarker) {
            map.removeLayer(anglePointMarker);
        }
        if (anglePoint) {
            anglePointMarker = L.marker([anglePoint.lat, anglePoint.lon], {color: 'red'}).addTo(map);
        }
    });

    document.getElementById('plan-path').addEventListener('click', function() {
        var startPointSelect = document.getElementById('start-point');
        var selectedStartPointOption = startPointSelect.options[startPointSelect.selectedIndex];
        var startPoint = selectedStartPointOption.value ? JSON.parse(selectedStartPointOption.value) : null;

        var anglePointSelect = document.getElementById('angle-point');
        var selectedAnglePointOption = anglePointSelect.options[anglePointSelect.selectedIndex];
        var anglePoint = selectedAnglePointOption.value ? JSON.parse(selectedAnglePointOption.value) : null;

        console.log('Start point:', startPoint);  // Debugging statement
        console.log('Angle point:', anglePoint);  // Debugging statement

        planBasicPath(startPoint, anglePoint);
    });

    function planBasicPath(startPoint, anglePoint) {
        fetch('http://127.0.0.1:5001/plan_basic_path', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                start_point: startPoint,
                angle_point: anglePoint
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                console.error('Error:', data.error);
            } else {
                console.log('Fetched path data:', data);
                if (pathLine) {
                    map.removeLayer(pathLine);
                }
                var pathCoordinates = data.map(function(coord) {
                    return [coord.lat, coord.lon];
                });
                console.log('Path coordinates for Leaflet:', pathCoordinates);
                pathLine = L.polyline(pathCoordinates, {color: 'blue'}).addTo(map);
            }
        })
        .catch((error) => {
            console.error('Error:', error);
        });
    }

    function updateDropdowns() {
        var startPointSelect = document.getElementById('start-point');
        var anglePointSelect = document.getElementById('angle-point');
        startPointSelect.innerHTML = '<option value="">Select a point</option>';
        anglePointSelect.innerHTML = '<option value="">Select a point</option>';
        currentPolygon.forEach(function(latlng, index) {
            var option = document.createElement('option');
            option.value = JSON.stringify({lat: latlng.lat, lon: latlng.lng});
            option.text = `Point ${index + 1}: (${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)})`;
            startPointSelect.appendChild(option);
            anglePointSelect.appendChild(option.cloneNode(true));
        });
        console.log('Dropdowns updated with points:', currentPolygon);
    }

    var ctx = document.getElementById('cpuChart').getContext('2d');
    var cpuChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: []
        },
        options: {
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: 'second'
                    }
                },
                y: {
                    beginAtZero: true,
                    max: 100
                }
            }
        }
    });

    function updateDashboard() {
        fetch('/data')
            .then(response => response.json())
            .then(data => {
                // Update polyline without changing the map's view
                var coordinates = data.gps_data.map(row => [row[1], row[2]]);
                polyline.setLatLngs(coordinates);

                // Update GPS data table
                var gpsDataTable = document.getElementById('gps-data-table');
                gpsDataTable.innerHTML = '<tr><th>Timestamp</th><th>Latitude</th><th>Longitude</th></tr>';
                data.gps_data.forEach(row => {
                    var tr = document.createElement('tr');
                    tr.innerHTML = `<td>${row[0]}</td><td>${row[1]}</td><td>${row[2]}</td>`;
                    gpsDataTable.appendChild(tr);
                });

                // Update CPU chart
                var labels = [];
                var datasets = {};

                data.cpu_data.forEach(row => {
                    if (!labels.includes(row[0])) {
                        labels.push(row[0]);
                    }
                    if (!datasets[`Core ${row[1]}`]) {
                        datasets[`Core ${row[1]}`] = {
                            label: `Core ${row[1]}`,
                            data: [],
                            borderColor: `rgba(${(row[1] * 50) % 255}, ${(row[1] * 100) % 255}, ${(row[1] * 150) % 255}, 1)`,
                            fill: false
                        };
                    }
                    datasets[`Core ${row[1]}`].data.push({ x: row[0], y: row[2] });
                });

                cpuChart.data.labels = labels;
                cpuChart.data.datasets = Object.values(datasets);
                cpuChart.update();

                // Update CPU data table
                var cpuDataTable = document.getElementById('cpu-data-table');
                cpuDataTable.innerHTML = '<tr><th>Timestamp</th><th>Core</th><th>CPU Usage (%)</th></tr>';
                data.cpu_data.forEach(row => {
                    var tr = document.createElement('tr');
                    tr.innerHTML = `<td>${row[0]}</td><td>${row[1]}</td><td>${row[2]}</td>`;
                    cpuDataTable.appendChild(tr);
                });
            })
            .catch(error => console.error('Error updating dashboard:', error));
    }

    setInterval(updateDashboard, 10000);  // Update every ten seconds
</script>
{% endblock %}